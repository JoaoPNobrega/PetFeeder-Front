<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Petfeed ‚Äî Documenta√ß√£o</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #111111;
      --card-bg: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --text-muted: #888888;
      --accent-green: #00ff88;
      --accent-blue: #00aaff;
      --border-color: rgba(255, 255, 255, 0.1);
      --shadow-dark: 0 8px 32px rgba(0, 0, 0, 0.6);
      --shadow-glow: 0 0 20px rgba(0, 255, 136, 0.3);
      --blur-bg: rgba(0, 0, 0, 0.8);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html { scroll-behavior: smooth; }
    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
      background: var(--bg-primary); color: var(--text-primary);
      line-height: 1.6; overflow-x: hidden;
    }
    body::before {
      content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background:
        radial-gradient(circle at 20% 20%, rgba(0, 255, 136, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(0, 170, 255, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 40% 60%, rgba(255, 68, 68, 0.03) 0%, transparent 50%);
      z-index: -1; animation: backgroundPulse 10s ease-in-out infinite alternate;
    }
    @keyframes backgroundPulse { 0% { opacity: 0.3; } 100% { opacity: 0.7; } }

    header {
      position: sticky; top: 0; z-index: 1000; background: var(--blur-bg);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border-color); padding: 1.5rem 2rem; text-align: center;
    }
    header h1 {
      font-size: 2.5rem; font-weight: 700;
      background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-blue) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; text-shadow: 0 0 30px rgba(0, 255, 136, 0.5); letter-spacing: -0.02em;
    }

    #sobreDashboard {
      display: block; grid-column: span 2; background: var(--bg-primary);
      border-radius: 24px; padding: 2rem; min-height: 400px;
      opacity: 1; transform: translateY(0);
      transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden; position: relative; z-index: 10;
      max-width: 1400px; margin: 3rem auto;
    }

    .secao-cinematica {
      display: flex; align-items: center; min-height: 80vh;
      position: relative; padding: 4rem 3rem;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      margin-bottom: 2rem; border-radius: 24px; overflow: hidden;
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      border: 1px solid var(--border-color); box-shadow: var(--shadow-dark);
    }
    .secao-cinematica:last-child { margin-bottom: 0; }
    .secao-cinematica.invertida { flex-direction: row-reverse; background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%); }
    #secao-requisitos .secao-cinematica { opacity: 0; transform: translateY(50px); margin-top: 4rem; }
    #secao-requisitos .secao-cinematica:first-of-type { margin-top: 0; }
    #secao-requisitos .secao-cinematica.is-visible { opacity: 1; transform: translateY(0px); }
    .secao-cinematica.is-pinned { }

    .conteudo-texto { flex: 1; padding: 2rem; z-index: 2; opacity: 1; }
    .conteudo-texto h2 {
      font-size: 3rem; font-weight: 700; margin-bottom: 2rem;
      background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-blue) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; line-height: 1.2; text-shadow: 0 4px 8px rgba(0,0,0,0.5);
      opacity: 1; filter: blur(0px);
    }
      .conteudo-texto h3 {
      font-size: 1.8rem; font-weight: 600; margin-bottom: 1.5rem;
      color: var(--accent-green); opacity: 1; filter: blur(0px);
      transition: filter 0.4s ease-out, opacity 0.4s ease-out;
    }
    .conteudo-texto p, .conteudo-texto pre {
      font-size: 1.2rem; line-height: 1.8; color: var(--text-secondary);
      margin-bottom: 1.5rem; text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      opacity: 0; filter: blur(6px); transform: translateY(20px);
      transition: opacity 0.5s ease-out, filter 0.5s ease-out, transform 0.5s ease-out;
    }
      #secao-prototipo .conteudo-texto p:first-of-type,
      #secao-versaoFinal .conteudo-texto p:first-of-type,
      #secao-primeiraVersao .conteudo-texto p:first-of-type { transform: translateY(0px); }
      #secao-requisitos .secao-cinematica:not(.static-text) .conteudo-texto pre { transform: translateY(0px); }
      .conteudo-texto pre {
        background-color: rgba(0,0,0,0.3); border: 1px solid var(--border-color);
        border-radius: 8px; padding: 1em; overflow-x: auto;
        font-family: 'Courier New', monospace; font-size: 0.85em;
        line-height: 1.6; color: #d0d0d0;
      }
    #secao-requisitos .secao-cinematica.static-text .conteudo-texto h3,
    #secao-requisitos .secao-cinematica.static-text .conteudo-texto pre {
        opacity: 1; filter: blur(0px); transform: translateY(0px);
    }
    .conteudo-midia {
      flex: 1; display: flex; align-items: center; justify-content: center;
      gap: 2rem; position: relative; height: 600px; z-index: 1;
    }
    .frame-scroll-container {
      position: relative; max-width: 500px; width: 100%; border-radius: 20px;
      box-shadow: 0 25px 50px rgba(0,0,0,0.7); border: 2px solid var(--border-color);
      overflow: hidden; background: #000; display: flex;
      align-items: center; justify-content: center; aspect-ratio: 16/9;
    }
    .frame-scroll-container.fixed-image-container {
        aspect-ratio: unset; height: auto; max-height: 500px;
        background: transparent; border: none; box-shadow: none;
    }
    .frame-scroll { width: 100%; height: 100%; object-fit: cover; display: block; transition: opacity 0.1s ease; }
    .frame-scroll.fixed-image {
        object-fit: contain; max-height: 100%; max-width: 100%;
        width: auto; height: auto; border-radius: 10px;
    }
    .slider-vertical-container { width: 40px; height: 400px; display: flex; align-items: center; justify-content: center; }
    .frame-slider-vertical {
      -webkit-appearance: none; appearance: none; width: 350px; height: 6px;
      background: #333; outline: none; border-radius: 3px; transform: rotate(-90deg);
      cursor: pointer; margin: 0; transition: background 0.2s ease;
    }
    .frame-slider-vertical:hover { background: #444; }
    .frame-slider-vertical::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; width: 24px; height: 24px;
      border-radius: 50%; background: var(--accent-green); cursor: pointer;
      border: 3px solid #fff; box-shadow: 0 0 15px rgba(0, 255, 136, 0.7);
      transition: transform 0.2s ease;
    }
    .frame-slider-vertical::-webkit-slider-thumb:hover { transform: scale(1.1); }
    .frame-slider-vertical::-moz-range-thumb {
      width: 24px; height: 24px; border-radius: 50%; background: var(--accent-green);
      cursor: pointer; border: 3px solid #fff; box-shadow: 0 0 15px rgba(0, 255, 136, 0.7);
      transition: transform 0.2s ease;
    }
    .frame-slider-vertical::-moz-range-thumb:hover { transform: scale(1.1); }
    .frame-slider-vertical::-moz-range-track { background: transparent; border: none; }
    .secao-cinematica::before {
      content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.4) 100%); z-index: 1;
    }

    .btn-secao {
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        border: 1px solid var(--border-color); border-radius: 16px; color: var(--text-primary);
        cursor: pointer; font-size: 0.9rem; font-weight: 600; padding: 1rem 1.5rem;
        position: relative; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); overflow: hidden;
        backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        text-transform: uppercase; letter-spacing: 0.5px;
        flex: 1; margin: 0;
    }
     .btn-secao::before {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }
    .btn-secao:hover::before { left: 100%; }
    .btn-secao:hover {
      transform: translateY(-2px); border-color: var(--accent-green);
      box-shadow: 0 8px 25px rgba(0, 255, 136, 0.2);
    }
    .btn-secao.ativo {
      background: linear-gradient(135deg, var(--accent-green) 0%, #00cc70 100%);
      box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
      border-color: var(--accent-green); color: #0a0a0a;
    }

    .navegacao-secoes {
      display: flex; justify-content: center; gap: 1rem; padding: 1rem 2rem;
      background: var(--blur-bg); backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px); border-radius: 20px;
      margin-bottom: 2rem; position: sticky; top: 100px;
      z-index: 999; border: 1px solid var(--border-color);
      max-width: 900px;
      margin-left: auto; margin-right: auto;
    }
    .progress-indicator { position: fixed; top: 86px; left: 0; width: 100%; height: 4px; background: rgba(255,255,255,0.1); z-index: 1001; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, var(--accent-green), var(--accent-blue)); width: 0%; transition: width 0.1s ease; box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
    .secao-conteudo { display: none; animation: fadeInUp 0.8s ease-out; padding-top: 20px; }
    .secao-conteudo.ativa { display: block; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(40px); } to { opacity: 1; transform: translateY(0); } }

    #secao-final {
      position: relative; width: 100%; height: 400vh;
      margin-top: 5rem; z-index: 5;
    }
    #frame-final-sticky-container {
      position: sticky; top: 0; width: 100%;
      height: 100vh; overflow: hidden;
    }
    #frame-final {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      object-fit: cover; opacity: 0; transition: opacity 0.3s ease;
    }
    #final-texto-overlay {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: #000000; display: flex; flex-direction: column;
      align-items: center; justify-content: center; text-align: center;
      z-index: 10000; opacity: 0; pointer-events: none;
      font-family: 'Segoe UI Black', 'Arial Black', sans-serif;
      text-transform: uppercase;
    }
    #final-texto-overlay h2 {
      font-size: 3.5rem; color: #fff; margin-bottom: 1rem;
      text-shadow: 0 0 5px #fff, 0 0 15px var(--accent-blue), 0 0 25px var(--accent-blue);
      letter-spacing: 0.1em;
    }
    #final-texto-overlay p {
      font-size: 1.5rem; color: var(--text-secondary); margin-bottom: 2rem;
      font-weight: normal; text-transform: none; text-shadow: none;
    }
    .github-link {
      display: inline-flex; align-items: center; gap: 1rem;
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      border: 1px solid var(--border-color); border-radius: 16px;
      color: var(--text-primary); text-decoration: none;
      font-size: 1.2rem; font-weight: 600; padding: 1rem 2rem;
      transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    }
    .github-link .fa-github { font-size: 24px; vertical-align: middle; }
    .github-link:hover {
      transform: translateY(-3px); border-color: var(--accent-green);
      box-shadow: 0 8px 30px rgba(0, 255, 136, 0.3); color: var(--accent-green);
    }

    @media (max-width: 992px) {
        .secao-cinematica { flex-direction: column !important; text-align: center; padding: 2rem 1.5rem; }
        .conteudo-midia { flex-direction: column; height: auto; gap: 1.5rem; }
        .slider-vertical-container { width: 100%; height: 60px; }
        .frame-slider-vertical { transform: rotate(0deg); width: 80%; height: 8px; }
        .frame-scroll-container.fixed-image-container { max-height: 300px; }
        #secao-requisitos .secao-cinematica.static-text.invertida .conteudo-midia { order: -1; }
        #secao-requisitos .secao-cinematica.static-text.invertida { flex-direction: column !important; }
        .secao-cinematica[data-requirement-id="interfacehtml"] { flex-direction: column !important; }
        .secao-cinematica[data-requirement-id="interfacehtml"].invertida { flex-direction: column !important; }
    }
    @media (min-width: 993px) {
        .secao-cinematica[data-requirement-id="interfacehtml"] { flex-direction: row !important; }
        .secao-cinematica[data-requirement-id="interfacehtml"].invertida { flex-direction: row-reverse !important; }
    }

    @media (max-width: 768px) {
      #sobreDashboard { padding: 1rem; margin: 1.5rem auto; }
      header h1 { font-size: 2rem; }
      .conteudo-texto h2, .conteudo-texto h3 { font-size: 2rem; }
      .navegacao-secoes { flex-direction: column; gap: 0.5rem; top: 100px;}
      .secao-conteudo { padding-top: 20px; }
      #final-texto-overlay h2 { font-size: 2.5rem; }
      #final-texto-overlay p { font-size: 1.2rem; }
      .github-link { font-size: 1rem; padding: 0.8rem 1.5rem; }
    }
    @keyframes slideInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
  </style>
</head>
<body>
  <div class="progress-indicator"> <div class="progress-bar" id="progressBar"></div> </div>
  <header> <h1>Petfeed ‚Äî Documenta√ß√£o</h1> </header>

  <div id="sobreDashboard" class="mostrar">
      <div class="navegacao-secoes">
          <button id="btnSecaoPrototipo" class="btn-secao ativo" data-secao="prototipo">ESP32</button>
          <button id="btnSecaoPrimeiraVersao" class="btn-secao" data-secao="primeiraVersao">Prot√≥tipo</button>
          <button id="btnSecaoVersaoFinal" class="btn-secao" data-secao="versaoFinal">Vers√£o Final</button>
          <button id="btnSecaoRequisitos" class="btn-secao" data-secao="requisitos">Requisitos</button>
      </div>

      <div id="secao-prototipo" class="secao-conteudo ativa">
        <div class="secao-cinematica" data-id="prototipo">
          <div class="conteudo-texto">
            <h2>ESP32</h2>
            <p>O objetivo inicial foi entender o funcionamento do ESP32 e atender aos requisitos da disciplina de Sistemas Embarcados. Come√ßamos com um sensor PIR, mas optamos pelo ultrass√¥nico, que se mostrou mais preciso para o projeto.</p>
            <p>Tamb√©m testamos o uso do potenci√¥metro, que controla o tempo at√© o motor retornar √† posi√ß√£o inicial, e adicionamos um LED para sinalizar a abertura do alimentador.</p>
            <p>Enfrentamos alguns desafios, como fios com mau contato e um superaquecimento nas primeiras tentativas ‚Äî parte natural do processo de aprendizagem e experimenta√ß√£o com o ESP32.</p>
          </div>
          <div class="conteudo-midia">
            <div class="frame-scroll-container">
              <video id="frame-prototipo" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/esp32.mp4" muted playsinline preload="auto" alt="ESP32 PetFeeder"></video>
            </div>
            <div class="slider-vertical-container"> <input type="range" class="frame-slider-vertical" id="slider-prototipo" min="0" max="1" step="0.01" value="0"> </div>
          </div>
        </div>
      </div>

      <div id="secao-primeiraVersao" class="secao-conteudo">
        <div class="secao-cinematica invertida" data-id="primeiraVersao"> <div class="conteudo-texto">
            <h2>Prot√≥tipo</h2> <p>A ideia inicial era utilizar impress√£o 3D, mas, por falta de experi√™ncia, optei por uma vers√£o caseira em papel√£o, focada apenas em testar a intera√ß√£o do sistema com o mundo real.</p>
            <p>Apesar da simplicidade, esse prot√≥tipo trouxe muito aprendizado. Pude entender melhor como trabalhar com o motor servo e sua fun√ß√£o de abrir a porta, al√©m de refletir sobre o que deveria ou n√£o ficar vis√≠vel no projeto.</p>
            <p>Ao final, decidi expor apenas o potenci√¥metro e o sensor ultrass√¥nico.</p>
          </div>
          <div class="conteudo-midia">
            <div class="frame-scroll-container">
              <video id="frame-primeiraVersao" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/petfeed.mp4" muted playsinline preload="auto" alt="Prot√≥tipo PetFeeder"></video>
            </div>
            <div class="slider-vertical-container">
              <input type="range" class="frame-slider-vertical" id="slider-primeiraVersao" min="0" max="1" step="0.01" value="0">
            </div>
          </div>
        </div>
      </div>

      <div id="secao-versaoFinal" class="secao-conteudo">
          <div class="secao-cinematica" data-id="versaoFinal"> <div class="conteudo-texto">
            <h2>Vers√£o Final</h2> <p>Esta vers√£o teve como foco corrigir pequenos problemas da estrutura de papel√£o, como a sa√≠da irregular da ra√ß√£o, causada pela forma como havia sido constru√≠da, a falta de fixa√ß√£o do potenci√¥metro e a aus√™ncia de prote√ß√£o adequada para o sensor ultrass√¥nico.</p>
            <p>Para a constru√ß√£o, utilizamos o aplicativo Fusion 360 para modelagem e aplicamos corte a laser nas pe√ßas.</p>
            <p>Essa vers√£o recebeu o nome PetFeed AT em refer√™ncia ao Amostra-Tech, a feira de ci√™ncias do CESAR School ‚Äî evento para o qual ela foi especialmente desenvolvida.</p>
          </div>
          <div class="conteudo-midia">
            <div class="frame-scroll-container">
              <video id="frame-versaoFinal" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/petfeederv1.mp4" muted playsinline preload="auto" alt="PetFeed V1"></video>
            </div>
            <div class="slider-vertical-container">
              <input type="range" class="frame-slider-vertical" id="slider-versaoFinal" min="0" max="1" step="0.01" value="0">
            </div>
          </div>
        </div>
      </div>

      <div id="secao-requisitos" class="secao-conteudo">
        <div class="secao-cinematica" data-requirement-id="led">
            <div class="conteudo-texto">
                <h3>Uso da LED (com PWM)</h3>
                <pre><code>int brilhoInicial = 255;
unsigned long tempoInicioAcionamento = 0;

void acionarServoNaoBloqueante(int tempoEmMs) {
  servo1.write(90);
  analogWrite(LED_PIN, brilhoInicial);
  tempoInicioAcionamento = millis();
  tempoAcionamento = tempoInicioAcionamento + tempoEmMs;
  servoAtivo = true;
}

void atualizarServo() {
  if (servoAtivo) {
    unsigned long agora = millis();

    if (agora >= tempoAcionamento) {
      servo1.write(0);
      analogWrite(LED_PIN, 0);
      servoAtivo = false;
    } else {
      int tempoTotal = tempoAcionamento - tempoInicioAcionamento;
      int tempoDecorrido = agora - tempoInicioAcionamento;
      int brilhoAtual = map(tempoDecorrido, 0, tempoTotal, brilhoInicial, 0);
      brilhoAtual = constrain(brilhoAtual, 0, 255);
      analogWrite(LED_PIN, brilhoAtual);
    }
  }
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container"> <video id="frame-req-led" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/led.mp4" muted playsinline preload="auto" alt="Requisito LED"></video> </div>
                <div class="slider-vertical-container"> <input type="range" class="frame-slider-vertical" id="slider-req-led" min="0" max="1" step="0.01" value="0"> </div>
            </div>
        </div>
        <div class="secao-cinematica invertida" data-requirement-id="botao">
            <div class="conteudo-texto">
                <h3>Uso do bot√£o f√≠sico</h3>
                <pre><code>#define BOTAO_PIN 33
bool estadoAnteriorBotao = HIGH;

void loop() {
  // ...
  bool estadoBotao = digitalRead(BOTAO_PIN);
  bool cliqueDetectado = (estadoAnteriorBotao == HIGH &amp;&amp; estadoBotao == LOW);
  estadoAnteriorBotao = estadoBotao;

  if (cliqueDetectado) {
    acionarServoNaoBloqueante(tempoEmMs);
    // enviarDadosParaFirebase(distancia, potValue, tempoEmMs, origemPrioritaria, "Abertura manual via bot√£o");
  }
  // ...
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container"> <video id="frame-req-botao" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/botao.mp4" muted playsinline preload="auto" alt="Requisito Bot√£o"></video> </div>
                <div class="slider-vertical-container"> <input type="range" class="frame-slider-vertical" id="slider-req-botao" min="0" max="1" step="0.01" value="0"> </div>
            </div>
        </div>
        <div class="secao-cinematica" data-requirement-id="motor">
            <div class="conteudo-texto">
                <h3>Uso do servo motor</h3>
                <pre><code>#include &lt;ESP32Servo.h&gt;
#define SERVO_PIN 27

Servo servo1;

void setup() {
  // ...
  servo1.attach(SERVO_PIN);
}

void acionarServoNaoBloqueante(int tempoEmMs) {
  servo1.write(90);
  // ...
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container"> <video id="frame-req-motor" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/motor.mp4" muted playsinline preload="auto" alt="Requisito Servo Motor"></video> </div>
                <div class="slider-vertical-container"> <input type="range" class="frame-slider-vertical" id="slider-req-motor" min="0" max="1" step="0.01" value="0"> </div>
            </div>
        </div>
        <div class="secao-cinematica invertida" data-requirement-id="sensor">
            <div class="conteudo-texto">
                <h3>Uso do sensor ultrass√¥nico</h3>
                <pre><code>#define TRIG_PIN 23
#define ECHO_PIN 22

float medirDistanciaCM() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duracao = pulseIn(ECHO_PIN, HIGH, 30000);
  float distancia = duracao * 0.034 / 2;
  return distancia;
}

void loop() {
  float distancia = medirDistanciaCM();

  if (distancia > 0 &amp;&amp; distancia &lt; 20) {
    acionarServoNaoBloqueante(tempoEmMs);
    // enviarDadosParaFirebase(distancia, potValue, tempoEmMs, origemPrioritaria, "Abertura autom√°tica por sensor");
  }
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container"> <video id="frame-req-sensor" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/sensor.mp4" muted playsinline preload="auto" alt="Requisito Sensor Ultrass√¥nico"></video> </div>
                <div class="slider-vertical-container"> <input type="range" class="frame-slider-vertical" id="slider-req-sensor" min="0" max="1" step="0.01" value="0"> </div>
            </div>
        </div>
        <div class="secao-cinematica" data-requirement-id="pot">
            <div class="conteudo-texto">
                <h3>Uso do potenci√¥metro</h3>
                <pre><code>#define POTENTIOMETER_PIN 32

int ultimoPotIndice = -1;
String origemPrioritaria = "potenciometro";
int tempoEmMs = 1000;

void loop() {
  int potValue = analogRead(POTENTIOMETER_PIN);
  int indicePot = map(potValue, 0, 4095, 0, 18);
  int tempoPotenciometro = 1000 + (indicePot * 500);

  if (indicePot == 0) {
    if (origemPrioritaria != "firebase") {
      origemPrioritaria = "firebase";
      // if (!modoAP) { Firebase.setString(fbdo, "/comando/origem", "firebase"); }
    }
  } else {
    if (indicePot != ultimoPotIndice) {
      if (origemPrioritaria != "potenciometro") {
        origemPrioritaria = "potenciometro";
        // if (!modoAP) { Firebase.setString(fbdo, "/comando/origem", "potenciometro"); }
      }
      ultimoPotIndice = indicePot;
      tempoEmMs = tempoPotenciometro;
      // if (!modoAP) { Firebase.setInt(fbdo, "/comando/tempo_remoto_ms", tempoEmMs); }
    }
  }
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container"> <video id="frame-req-pot" class="frame-scroll" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/pot.mp4" muted playsinline preload="auto" alt="Requisito Potenci√¥metro"></video> </div>
                <div class="slider-vertical-container"> <input type="range" class="frame-slider-vertical" id="slider-req-pot" min="0" max="1" step="0.01" value="0"> </div>
            </div>
        </div>
        <div class="secao-cinematica invertida static-text" data-requirement-id="firebase">
            <div class="conteudo-texto">
                <h3>Uso do Firebase</h3>
                <pre><code>#include &lt;FirebaseESP32.h&gt;

FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

void iniciarFirebase() {
  config.database_url = DATABASE_URL;
  config.signer.tokens.legacy_token = DATABASE_SECRET;
  Firebase.reconnectNetwork(true);
  fbdo.setBSSLBufferSize(4096, 1024);
  Firebase.begin(&amp;config, &amp;auth);
}

void enviarDadosParaFirebase(float distancia, int potValue, int tempo, const String &amp;modo, const String &amp;evento) {
  if (modoAP || !Firebase.ready()) return;

  Firebase.setFloat(fbdo, "/estado/distancia_cm", distancia);
  Firebase.setInt(fbdo, "/estado/potenciometro", potValue);
  Firebase.setInt(fbdo, "/estado/tempo_aberto_ms", tempo);
  Firebase.setString(fbdo, "/estado/modo", modo);
  Firebase.setString(fbdo, "/estado/evento", evento);
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container fixed-image-container"> <img id="img-req-firebase" class="frame-scroll fixed-image" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/firebase.png" alt="Requisito Firebase"> </div>
            </div>
        </div>
        <div class="secao-cinematica static-text" data-requirement-id="ap"> <div class="conteudo-texto">
                <h3>Cria√ß√£o do Wi-Fi pr√≥prio (Access Point)</h3>
                <pre><code>void configurarWiFiDuplo() {
  WiFi.mode(WIFI_AP_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Conectando √† rede Wi-Fi local...");
  unsigned long tempoInicial = millis();
  while (WiFi.status() != WL_CONNECTED &amp;&amp; millis() - tempoInicial &lt; 10000) {
    Serial.print(".");
    delay(500);
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("\nConectado! IP local: http://");
    Serial.print(WiFi.localIP());
    Serial.println("/index.html");
    modoAP = false;
  } else {
    Serial.println("\nFalha ao conectar. Iniciando AP...");
    const char* ssidAP = "PetFeeder";
    const char* senhaAP = "senha1234";
    WiFi.softAP(ssidAP, senhaAP);
    Serial.print("Access Point iniciado! IP: ");
    Serial.println(WiFi.softAPIP());
    modoAP = true;
  }
}</code></pre>
            </div>
            <div class="conteudo-midia">
                <div class="frame-scroll-container fixed-image-container"> <img id="img-req-ap" class="frame-scroll fixed-image" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/AP.png" alt="Requisito Access Point"> </div>
            </div>
        </div>
        <div class="secao-cinematica static-text" data-requirement-id="interfacehtml"> <div class="conteudo-texto">
                <h3>Interface HTML embutida no ESP32</h3>
                <pre><code>const char SIMPLE_HTML_PAGE[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE html&gt;
&lt;html lang="pt-BR"&gt;
&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;
&lt;title&gt;PetFeeder Local&lt;/title&gt;
&lt;!-- Linha de estilo removida --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Controle PetFeeder&lt;/h1&gt;
&lt;input type="number" id="tempo" placeholder="Tempo em ms" min="1000" max="10000"&gt;&lt;br&gt;
&lt;button onclick="abrir()"&gt;üîì Abrir Porta&lt;/button&gt;
&lt;div id="status"&gt;Status: aguardando a√ß√£o...&lt;/div&gt;
&lt;script&gt;
async function abrir() {
  const tempo = document.getElementById('tempo').value || 3000;
  const res = await fetch("/abrir?tempo=" + tempo);
  const txt = await res.text();
  document.getElementById("status").innerText = "Status: " + txt;
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
)rawliteral";</code></pre>
            </div>
            <div class="conteudo-midia">
                  <div class="frame-scroll-container fixed-image-container">
                    <img id="img-req-interface" class="frame-scroll fixed-image" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/interfaceAP.png" alt="Requisito Interface HTML">
                  </div>
            </div>
        </div>
      </div>
  </div>

  <div id="secao-final">
      <div id="frame-final-sticky-container">
          <video id="frame-final" class="frame-scroll-final" src="https://joaopnobrega.github.io/PetFeeder-Front/Embarcados2/data/frames/caixa.mp4" muted playsinline preload="auto" alt="Anima√ß√£o Final"></video>
          <div id="final-texto-overlay">
              <h2>Espero que tenha gostado</h2>
              <p>Para saber mais:</p>
              <a href="https://github.com/JoaoPNobrega/PetFeeder-Front" target="_blank" class="github-link">
                  <i class="fa-brands fa-github"></i>
                  <span>JoaoPNobrega/PetFeeder-Front</span>
              </a>
          </div>
      </div>
  </div>

  <script type="module">
     let videoScrollSystems = [];
     let requisitosObservers = [];
     let pinnableObserver = null;
     let activePinnableSection = null;
     let requisitosScrollListenerActive = false;
     let activeRequisitosScrollSystem = null;
     let finalSectionActive = false;

     const finalSectionElement = document.getElementById('secao-final');
     const finalVideoElement = document.getElementById('frame-final');
     const finalTextOverlay = document.getElementById('final-texto-overlay');
     let finalVideoDuration = 0;
     let isFinalVideoReady = false;

     class VideoScrollSystem {
        constructor(videoElement, sliderElement, isStaticTextRequirement = false, isMainSection = true, sectionElement) {
            this.videoElement = videoElement; this.sliderElement = sliderElement; this.isStaticTextRequirement = isStaticTextRequirement;
            this.isMainSection = isMainSection; this.parentCinematicSection = sectionElement; this.duration = 0; this.isReady = false;
            this.textContainer = null; this.hElement = null; this.pElements = []; this.preElement = null;
            if (this.parentCinematicSection) {
                this.textContainer = this.parentCinematicSection.querySelector('.conteudo-texto');
                if (this.textContainer) {
                    this.hElement = (this.textContainer.querySelector('h2') || this.textContainer.querySelector('h3'));
                    if (this.isMainSection) this.pElements = Array.from(this.textContainer.querySelectorAll('p'));
                    else this.preElement = this.textContainer.querySelector('pre');
                }
            }
            if (this.videoElement && !this.isStaticTextRequirement) {
                this.videoElement.addEventListener('loadedmetadata', () => {
                    this.duration = this.videoElement.duration; this.isReady = true;
                    if (this.sliderElement) { this.sliderElement.min = 0; this.sliderElement.max = 1; this.sliderElement.step = 0.005; this.sliderElement.value = 0; }
                    this.videoElement.pause(); this.updateProgress(0);
                });
                this.videoElement.pause();
            } else { this.isReady = true; }
            this.setInitialTextState();
        }
        setInitialTextState() {
             if (this.hElement) { this.hElement.style.opacity = '1'; this.hElement.style.filter = 'blur(0px)'; }
             if (this.isStaticTextRequirement) { if (this.preElement) { this.preElement.style.opacity = '1'; this.preElement.style.filter = 'blur(0px)'; this.preElement.style.transform = 'translateY(0px)'; } }
             else if (this.isMainSection) {
                 if (this.pElements.length > 0) { this.pElements.forEach((p, index) => { p.style.opacity = index === 0 ? '0.3' : '0'; p.style.filter = `blur(${index === 0 ? 4 : 6}px)`; p.style.transform = `translateY(${index === 0 ? 0 : 20}px)`; }); }
             } else { if (this.preElement) { this.preElement.style.opacity = '0'; this.preElement.style.filter = 'blur(6px)'; this.preElement.style.transform = 'translateY(0px)'; } }
        }
        updateProgress(progress) {
            if (this.isStaticTextRequirement) { this.setInitialTextState(); return; }
            if (!this.videoElement || !this.isReady || this.duration === 0) return;
            progress = Math.max(0, Math.min(1, progress)); const newTime = progress * this.duration;
            if (Math.abs(this.videoElement.currentTime - newTime) > 0.033) { this.videoElement.currentTime = newTime; }
            if (this.sliderElement && parseFloat(this.sliderElement.value) !== progress) { this.sliderElement.value = progress; }
            if (this.hElement) { this.hElement.style.opacity = '1'; this.hElement.style.filter = 'blur(0px)'; }
            if (this.isMainSection && this.pElements.length > 0) {
                this.pElements.forEach((p, index) => {
                    const pStartProgressBase = 0.01, pStaggerFactor = 0.1, pDurationProgress = 0.3; let pStartProgress = (index === 0) ? pStartProgressBase : pStartProgressBase + 0.05 + ((index-1) * pStaggerFactor);
                    let pProgress = Math.min(1, Math.max(0, (progress - pStartProgress) / pDurationProgress));

                    if (index === 0) {
                        if (pProgress >= 0.99) {
                            p.style.opacity = 1;
                            p.style.filter = 'none';
                        } else {
                            p.style.opacity = pProgress < 0.3 ? Math.max(pProgress, 0.3) : pProgress;
                            p.style.filter = `blur(${(1 - pProgress) * 4}px)`;
                        }
                        p.style.transform = 'translateY(0px)';
                    } else {
                        if (pProgress >= 0.99) {
                            p.style.opacity = 1;
                            p.style.filter = 'none';
                        } else {
                            p.style.opacity = pProgress;
                            p.style.filter = `blur(${(1 - pProgress) * 6}px)`;
                        }
                        p.style.transform = `translateY(${(1 - pProgress) * 20}px)`;
                    }
                });
            } else if (!this.isMainSection && this.preElement) { // Para blocos <pre>
                const preStartProgress = 0.01, preDurationProgress = 0.4; let currentPreProgress = (progress >= preStartProgress) ? (progress - preStartProgress) / preDurationProgress : 0;
                currentPreProgress = Math.min(1, Math.max(0, currentPreProgress));
                 if (currentPreProgress >= 0.99) {
                    this.preElement.style.opacity = 1;
                    this.preElement.style.filter = 'none';
                } else {
                    this.preElement.style.opacity = currentPreProgress;
                    this.preElement.style.filter = `blur(${(1 - currentPreProgress) * 6}px)`;
                }
                this.preElement.style.transform = 'translateY(0px)';
            }
        }
     }

     async function preloadVideoAsBlob(url, videoElement) {
        try {
            console.log("Iniciando pr√©-carregamento:", url);
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const videoBlob = await response.blob();
            const blobUrl = URL.createObjectURL(videoBlob);
            videoElement.src = blobUrl;
            console.log("V√≠deo pr√©-carregado como blob:", blobUrl);
        } catch (error) {
            console.error("Falha ao pr√©-carregar v√≠deo como blob. Usando URL original.", error);
            videoElement.src = url;
        }
     }

     function initVideoScrollSystems() {
        videoScrollSystems = [];
        const sectionsData = [
            { id: 'prototipo', videoId: 'frame-prototipo', sliderId: 'slider-prototipo', isMain: true, isStatic: false, requirementIdForQuery: 'prototipo' },
            { id: 'primeiraVersao', videoId: 'frame-primeiraVersao', sliderId: 'slider-primeiraVersao', isMain: true, isStatic: false, requirementIdForQuery: 'primeiraVersao' },
            { id: 'versaoFinal', videoId: 'frame-versaoFinal', sliderId: 'slider-versaoFinal', isMain: true, isStatic: false, requirementIdForQuery: 'versaoFinal' },
            { id: 'req-led', videoId: 'frame-req-led', sliderId: 'slider-req-led', isMain: false, isStatic: false, requirementIdForQuery: 'led' },
            { id: 'req-botao', videoId: 'frame-req-botao', sliderId: 'slider-req-botao', isMain: false, isStatic: false, requirementIdForQuery: 'botao' },
            { id: 'req-motor', videoId: 'frame-req-motor', sliderId: 'slider-req-motor', isMain: false, isStatic: false, requirementIdForQuery: 'motor' },
            { id: 'req-sensor', videoId: 'frame-req-sensor', sliderId: 'slider-req-sensor', isMain: false, isStatic: false, requirementIdForQuery: 'sensor' },
            { id: 'req-pot', videoId: 'frame-req-pot', sliderId: 'slider-req-pot', isMain: false, isStatic: false, requirementIdForQuery: 'pot' },
            { id: 'req-firebase', isStatic: true, isMain: false, frameImgId: 'img-req-firebase', requirementIdForQuery: 'firebase' },
            { id: 'req-ap', isStatic: true, isMain: false, frameImgId: 'img-req-ap', requirementIdForQuery: 'ap' },
            { id: 'req-interfacehtml', isStatic: true, isMain: false, frameImgId: 'img-req-interface', requirementIdForQuery: 'interfacehtml' }
        ];
        sectionsData.forEach(data => {
            const videoElement = data.videoId ? document.getElementById(data.videoId) : null;
            const imgElement = data.frameImgId ? document.getElementById(data.frameImgId) : null;
            const sliderElement = data.sliderId ? document.getElementById(data.sliderId) : null;
            let querySelector = `.secao-cinematica[data-id="${data.requirementIdForQuery}"]`;
            if (!data.isMain) {
                 querySelector = `.secao-cinematica[data-requirement-id="${data.requirementIdForQuery}"]`;
            }
            let sectionElement = document.querySelector(querySelector);

            if (sectionElement) {
                const system = new VideoScrollSystem(videoElement, sliderElement, data.isStatic, data.isMain, sectionElement);
                videoScrollSystems.push({ id: data.id, system: system, slider: sliderElement, isStatic: data.isStatic, sectionElement: sectionElement });
            } else { console.warn("Section element not found for:", data.id, " with selector:", querySelector); }
        });
        videoScrollSystems.forEach(vs => { if (vs.slider && !vs.isStatic) { vs.slider.addEventListener('input', () => { if(vs.system) vs.system.updateProgress(parseFloat(vs.slider.value)) }); } });
     }
     function handlePinnableWheel(event) {
        if (!activePinnableSection) return;
        const vsWrapper = videoScrollSystems.find(f => f.sectionElement === activePinnableSection);
        if (!vsWrapper || !vsWrapper.slider || vsWrapper.isStatic) return;
        const system = vsWrapper.system; const slider = vsWrapper.slider; let currentProgress = parseFloat(slider.value);
        const step = event.deltaY > 0 ? 0.02 : -0.02; let newProgress = currentProgress + step;
        newProgress = Math.max(0, Math.min(1, newProgress));
        if ((event.deltaY < 0 && currentProgress <= 0) || (event.deltaY > 0 && currentProgress >= 1)) return;
        event.preventDefault();
        system.updateProgress(newProgress);
     }
     function handleRequisitosPageScroll() {
        if (!requisitosScrollListenerActive) return; let bestCandidateSystem = null; let highestVisibilityScore = -1;
        const viewportHeight = window.innerHeight; const viewportCenter = viewportHeight / 2;
        document.querySelectorAll('#secao-requisitos .secao-cinematica.is-visible').forEach(section => {
            const reqId = section.dataset.requirementId; const vsWrapper = videoScrollSystems.find(vs => vs.id === `req-${reqId}` && !vs.isStatic && vs.slider);
            if (!vsWrapper) return; const rect = section.getBoundingClientRect(); if (rect.bottom < 0 || rect.top > viewportHeight) return;
            const verticalCenterOfBlock = rect.top + rect.height / 2; const distanceToViewportCenter = Math.abs(viewportCenter - verticalCenterOfBlock);
            const score = 1 - (distanceToViewportCenter / (viewportHeight / 2));
            if (score > highestVisibilityScore) { highestVisibilityScore = score; bestCandidateSystem = vsWrapper; }
        });
        activeRequisitosScrollSystem = bestCandidateSystem;
        if (activeRequisitosScrollSystem) {
            const block = activeRequisitosScrollSystem.sectionElement; const rect = block.getBoundingClientRect();
            let progress = (viewportCenter - rect.top) / rect.height; progress = Math.max(0, Math.min(1, progress));
            activeRequisitosScrollSystem.system.updateProgress(progress);
        }
     }
     function handleFinalScroll() {
        const rect = finalSectionElement.getBoundingClientRect(); const viewportHeight = window.innerHeight;
        if (!finalVideoElement || !finalTextOverlay) return;
        if (rect.bottom < 0 || rect.top > viewportHeight) {
            finalSectionActive = false; finalVideoElement.style.opacity = 0; finalTextOverlay.style.opacity = 0; finalTextOverlay.style.pointerEvents = 'none';
            if (rect.top > viewportHeight && finalVideoDuration > 0) { finalVideoElement.currentTime = 0; } return;
        }
        finalSectionActive = true; let progress = (-rect.top) / (finalSectionElement.offsetHeight - viewportHeight);
        progress = Math.max(0, Math.min(1, progress));
        if (isFinalVideoReady && finalVideoDuration > 0) {
             const newTime = progress * finalVideoDuration;
             if (Math.abs(finalVideoElement.currentTime - newTime) > 0.04) { finalVideoElement.currentTime = newTime; }
        }
        const imageFadeInStart = 0.10, imageFadeInEnd = 0.25; const textFadeInStart = 0.85, textFadeInEnd = 1.0;
        let textOpacity = 0, imageOpacity = 0;
        if (progress < imageFadeInStart) { imageOpacity = 0; }
        else if (progress >= imageFadeInStart && progress < imageFadeInEnd) { imageOpacity = (progress - imageFadeInStart) / (imageFadeInEnd - imageFadeInStart); }
        else if (progress >= imageFadeInEnd && progress < textFadeInStart) { imageOpacity = 1; }
        else if (progress >= textFadeInStart && progress <= textFadeInEnd) { imageOpacity = 1 - ((progress - textFadeInStart) / (textFadeInEnd - textFadeInStart)); }
        else { imageOpacity = 0; }
        if (progress >= textFadeInStart && progress <= textFadeInEnd) { textOpacity = (progress - textFadeInStart) / (textFadeInEnd - textFadeInStart); }
        else if (progress > textFadeInEnd) { textOpacity = 1; }
        else { textOpacity = 0; }
        finalVideoElement.style.opacity = Math.max(0, Math.min(1, imageOpacity));
        finalTextOverlay.style.opacity = Math.max(0, Math.min(1, textOpacity));
        finalTextOverlay.style.pointerEvents = (textOpacity > 0.5) ? 'auto' : 'none';
     }
     function handleScroll() {
        const scrollY = window.scrollY; const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = docHeight > 0 ? (scrollY / docHeight) * 100 : 0;
        const progressBar = document.getElementById('progressBar'); if (progressBar) progressBar.style.width = `${scrollPercent}%`;
     }
     function handleGlobalScroll() {
        handleScroll(); const finalRect = finalSectionElement.getBoundingClientRect();
        const sobreDashboardElement = document.getElementById('sobreDashboard');
        if (sobreDashboardElement && window.getComputedStyle(sobreDashboardElement).display !== 'none') {
            const sobreDashboardRect = sobreDashboardElement.getBoundingClientRect();
            if (sobreDashboardRect.bottom < window.innerHeight / 2) {
                if (finalRect.top <= window.innerHeight && finalRect.bottom >= 0) {
                    handleFinalScroll(); if (finalSectionActive) { requisitosScrollListenerActive = false; return; }
                } else {
                    if (finalSectionActive) {
                        finalSectionActive = false; finalVideoElement.style.opacity = 0; finalTextOverlay.style.opacity = 0;
                        finalTextOverlay.style.pointerEvents = 'none'; if(finalVideoDuration > 0) finalVideoElement.currentTime = 0;
                    }
                }
            }
            if (requisitosScrollListenerActive && !finalSectionActive) { handleRequisitosPageScroll(); }
        }
     }
     function createPinnableObserver() {
        const observerOptions = { root: null, rootMargin: '0px', threshold: 0.9 };
        pinnableObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const targetElement = entry.target;
                if (entry.isIntersecting && entry.intersectionRatio >= 0.9) {
                    if (activePinnableSection !== targetElement) {
                        if (activePinnableSection) { activePinnableSection.removeEventListener('wheel', handlePinnableWheel); activePinnableSection.classList.remove('is-pinned'); }
                        activePinnableSection = targetElement; const vsWrapper = videoScrollSystems.find(f => f.sectionElement === targetElement);
                        if(vsWrapper && !vsWrapper.isStatic && vsWrapper.slider) {
                             targetElement.addEventListener('wheel', handlePinnableWheel, { passive: false });
                        }
                        targetElement.classList.add('is-pinned');
                    }
                } else {
                    if (targetElement === activePinnableSection) { targetElement.removeEventListener('wheel', handlePinnableWheel); targetElement.classList.remove('is-pinned'); activePinnableSection = null; }
                }
            });
        }, observerOptions);
     }
     function activatePinnableSections() { if (!pinnableObserver) createPinnableObserver(); pinnableObserver.disconnect(); document.querySelectorAll('#secao-prototipo .secao-cinematica, #secao-primeiraVersao .secao-cinematica, #secao-versaoFinal .secao-cinematica').forEach(el => pinnableObserver.observe(el)); }
     function deactivatePinnableSections() { if (pinnableObserver) pinnableObserver.disconnect(); if (activePinnableSection) { activePinnableSection.removeEventListener('wheel', handlePinnableWheel); activePinnableSection.classList.remove('is-pinned'); activePinnableSection = null; } }
     function activateRequisitosObserver() { requisitosObservers.forEach(obs => obs.disconnect()); requisitosObservers = []; const requisitosSections = document.querySelectorAll('#secao-requisitos .secao-cinematica'); if (requisitosSections.length > 0) { const entryObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 }; const entryObserver = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) entry.target.classList.add('is-visible'); }); }, entryObserverOptions); requisitosSections.forEach(section => entryObserver.observe(section)); requisitosObservers.push(entryObserver); } }
     function deactivateRequisitosObservers() { requisitosObservers.forEach(obs => obs.disconnect()); requisitosObservers = []; }
     function mostrarSecao(secaoId) {
        document.querySelectorAll('.secao-conteudo').forEach(div => div.classList.remove('ativa'));
        document.querySelectorAll('.btn-secao').forEach(btn => btn.classList.remove('ativo'));
        const secaoSelecionada = document.getElementById(`secao-${secaoId}`); if (secaoSelecionada) secaoSelecionada.classList.add('ativa');
        const botaoSelecionado = document.querySelector(`.btn-secao[data-secao="${secaoId}"]`); if (botaoSelecionado) botaoSelecionado.classList.add('ativo');

        deactivatePinnableSections(); deactivateRequisitosObservers();
        requisitosScrollListenerActive = false; finalSectionActive = false;

        if (secaoId === 'prototipo' || secaoId === 'versaoFinal' || secaoId === 'primeiraVersao') {
            activatePinnableSections();
        } else if (secaoId === 'requisitos') {
            activateRequisitosObserver();
            requisitosScrollListenerActive = true;
        }

        videoScrollSystems.forEach(vs => {
            const isCurrentSystemActive = vs.sectionElement && vs.sectionElement.closest('.secao-conteudo.ativa');
            if (isCurrentSystemActive && vs.system) {
                vs.system.setInitialTextState();
                if (!vs.isStatic && vs.system.isReady && vs.slider) {
                    vs.system.updateProgress(0);
                    vs.slider.value = 0;
                }
            }
        });
        setTimeout(handleScroll, 100);
     }

     document.addEventListener('DOMContentLoaded', function() {
        initVideoScrollSystems();
        createPinnableObserver();

        finalVideoElement.addEventListener('loadedmetadata', () => {
            finalVideoDuration = finalVideoElement.duration;
            isFinalVideoReady = true;
            finalVideoElement.pause();
            handleFinalScroll();
            console.log("V√≠deo final pronto. Dura√ß√£o:", finalVideoDuration);
        });
        preloadVideoAsBlob(finalVideoElement.src, finalVideoElement);

        let tickingScroll = false;
        window.addEventListener('scroll', () => { if (!tickingScroll) { window.requestAnimationFrame(() => { handleGlobalScroll(); tickingScroll = false; }); tickingScroll = true; } });
        window.addEventListener('resize', handleScroll);

        document.getElementById('btnSecaoPrototipo').addEventListener('click', () => mostrarSecao('prototipo'));
        document.getElementById('btnSecaoPrimeiraVersao').addEventListener('click', () => mostrarSecao('primeiraVersao'));
        document.getElementById('btnSecaoVersaoFinal').addEventListener('click', () => mostrarSecao('versaoFinal'));
        document.getElementById('btnSecaoRequisitos').addEventListener('click', () => mostrarSecao('requisitos'));

        document.getElementById('sobreDashboard').classList.add('mostrar');
        mostrarSecao('prototipo');
        finalVideoElement.style.opacity = 0;
        finalTextOverlay.style.opacity = 0;
     });

     if ('serviceWorker' in navigator) navigator.serviceWorker.register('data:text/javascript,').catch(() => {});
     const style = document.createElement('style');
     style.textContent = `@keyframes rainbow { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } } @keyframes glow { 0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); } 50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.8); } }`;
     document.head.appendChild(style);

  </script>
</body>
</html>